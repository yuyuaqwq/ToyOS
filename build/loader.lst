     1                                  %include "boot.inc"
     2                              <1> ;----------Loader----------
     3                              <1> LOADER_BASE_ADDR equ 0x900
     4                              <1> LOADER_ENTRY equ LOADER_BASE_ADDR + 0x300
     5                              <1> LOADER_START_SECTOR equ 0x2
     6                              <1> 
     7                              <1> PAGE_DIR_TABLE_POS equ 0x100000
     8                              <1> 
     9                              <1> ;----------kernel----------
    10                              <1> KERNEL_BIN_BASE_ADDR equ 0x70000
    11                              <1> KERNEL_ENTRY_POINT equ 0xc0001500
    12                              <1> KERNEL_START_SECTOR equ 0x9
    13                              <1> 
    14                              <1> ;----------gtd描述符属性----------
    15                              <1> DESC_G_4K equ (1b << 23)
    16                              <1> DESC_D_32 equ (1b << 22)
    17                              <1> DESC_L equ (0b << 21)      ; 64位代码标记
    18                              <1> DESC_AVL equ (0b << 20)        ; CPU未使用
    19                              <1> DESC_LIMIT_CODE2 equ (0xf << 16)
    20                              <1> DESC_LIMIT_DATA2 equ (0xf << 16)
    21                              <1> DESC_LIMIT_VIDEO2 equ (0x0 << 16)
    22                              <1> DESC_P equ (1b << 15)
    23                              <1> DESC_DPL_0 equ (0x0 << 13)
    24                              <1> DESC_DPL_1 equ (0x1 << 13)
    25                              <1> DESC_DPL_2 equ (0x2 << 13)
    26                              <1> DESC_DPL_3 equ (0x3 << 13)
    27                              <1> DESC_S_CODE equ (1b << 12)
    28                              <1> DESC_S_DATA equ (1b << 12)
    29                              <1> DESC_S_SYS equ (0b << 12)
    30                              <1> DESC_TYPE_CODE equ (0x8 << 8)
    31                              <1> DESC_TYPE_DATA equ (0x2 << 8)
    32                              <1> 
    33                              <1> DESC_CODE_HIGH4 equ ((0x00 << 24) | DESC_G_4K | DESC_D_32 | DESC_L | DESC_AVL | DESC_LIMIT_CODE2 | DESC_P | DESC_DPL_0 | DESC_S_CODE | DESC_TYPE_CODE | 0x00)
    34                              <1> DESC_DATA_HIGH4 equ ((0x00 << 24) | DESC_G_4K | DESC_D_32 | DESC_L | DESC_AVL | DESC_LIMIT_DATA2 | DESC_P | DESC_DPL_0 | DESC_S_DATA | DESC_TYPE_DATA | 0x00)
    35                              <1> DESC_VIDEO_HIGH4 equ ((0x00 << 24) | DESC_G_4K | DESC_D_32 | DESC_L | DESC_AVL | DESC_LIMIT_VIDEO2 | DESC_P | DESC_DPL_0 | DESC_S_DATA | DESC_TYPE_DATA | 0x0b)
    36                              <1> 
    37                              <1> ;----------段选择子属性----------
    38                              <1> RPL0 equ 00b
    39                              <1> RPL1 equ 01b
    40                              <1> RPL2 equ 10b
    41                              <1> RPL3 equ 11b
    42                              <1> TI_GDT equ (0b << 2)
    43                              <1> TI_LDT equ (1b << 2)
    44                              <1> 
    45                              <1> ;----------页表项属性----------
    46                              <1> PG_P equ 1b
    47                              <1> PG_RW_R equ (0b << 1)
    48                              <1> PG_RW_W equ (1b << 1)
    49                              <1> PG_US_S equ (0b << 2)
    50                              <1> PG_US_U equ (1b << 2)
     2                                  section loader vstart=LOADER_BASE_ADDR
     3                                  
     4                                  LOADER_STACK_TOP equ LOADER_BASE_ADDR
     5                                  
     6                                  SELECTOR_CODE equ (0x0001 << 3) | TI_GDT | RPL0
     7                                  SELECTOR_DATA equ (0x0002 << 3) | TI_GDT | RPL0
     8                                  SELECTOR_VIDEO equ (0x0003 << 3) | TI_GDT | RPL0
     9                                  
    10                                  
    11                                  ; Loader data: 0x900
    12                                  
    13                                  ; GDT，全局描述符表
    14                                  GDT_BASE:
    15 00000000 00000000                    dd 0x00000000
    16 00000004 00000000                    dd 0x00000000
    17                                  
    18                                  CODE_DESC:
    19 00000008 FFFF0000                    dd 0x0000ffff
    20 0000000C 0098CF00                    dd DESC_CODE_HIGH4
    21                                  
    22                                  DATA_STACK_DESC:
    23 00000010 FFFF0000                    dd 0x0000ffff
    24 00000014 0092CF00                    dd DESC_DATA_HIGH4
    25                                  
    26                                  VIDEO_DESC:
    27 00000018 07000080                    dd 0x80000007
    28 0000001C 0B92C000                    dd DESC_VIDEO_HIGH4
    29                                  
    30                                  GDT_SIZE equ $ - GDT_BASE
    31                                  GDT_LIMIT equ GDT_SIZE - 1
    32                                  
    33 00000020 0000000000000000-           times 60 dq 0       ; 预留60个描述符空位
    33 00000020 <rep 3Ch>          
    34                                  
    35                                  
    36                                  ; 物理内存总数，在内存中的地址是0xb00
    37 00000200 00000000                    memBytesTotal dd 0
    38                                  
    39                                  
    40                                  ; lgdt时提供的48位数据
    41 00000204 1F00                        gdtPtr dw GDT_LIMIT
    42 00000206 [00000000]                          dd GDT_BASE
    43                                      
    44                                  ; 除开GDT外的数据区为256字节
    45 0000020A 00<rep F4h>                 ardsBuf times 244 db 0
    46 000002FE 0000                        ardsNr dw 0     ; 记录ARDS结构体数量
    47                                      
    48                                  
    49                                  
    50                                  
    51                                  ; Loader code: 0x900+0x300
    52                                  loaderStart:
    53                                  
    54 00000300 6631DB                      xor ebx, ebx
    55 00000303 66BA50414D53                mov edx, 0x534d4150
    56 00000309 BF[0A02]                    mov di, ardsBuf
    57                                  
    58                                  ; 0xE820 方法获取物理内存信息
    59                                  .e820MemGetLoop:
    60 0000030C 66B820E80000                mov eax, 0x0000e820     ; 每次都要更新子功能号
    61 00000312 66B914000000                mov ecx, 20     ; ARDS地址范围描述符结构体大小是20字节
    62 00000318 CD15                        int 0x15
    63 0000031A 7232                        jc .e801MemGetLoop       ; cf为1表示发生错误，使用其他方法
    64                                  
    65 0000031C 01CF                        add di, cx      ; 更新缓冲区指针
    66 0000031E FF06[FE02]                  inc word [ardsNr]       ; ARDS数量
    67 00000322 6683FB00                    cmp ebx, 0      ; ebx为0且cf不为1，说明ARDS全部返回
    68 00000326 75E4                        jnz .e820MemGetLoop     ; 获取下一个
    69                                  
    70                                  ; 遍历ARDS结构获取总大小
    71 00000328 8B0E[FE02]                  mov cx, [ardsNr]
    72 0000032C 66BB[0A020000]              mov ebx, ardsBuf
    73 00000332 6631D2                      xor edx, edx
    74                                  
    75                                  .findMaxMemArea:
    76 00000335 66678B03                    mov eax, [ebx]      ; base_add_low
    77 00000339 6667034308                  add eax, [ebx+8]    ; +length_low，比如总大小是0x1000，最后一块是0xc00 + 0x400，正好就是总大小
    78 0000033E 6683C314                    add ebx, 20
    79 00000342 6639C2                      cmp edx, eax
    80 00000345 7D03                        jge .nextArds
    81 00000347 6689C2                      mov edx, eax        ; 更新最大的内存容量
    82                                  
    83                                  .nextArds:
    84 0000034A E2E9                        loop .findMaxMemArea
    85 0000034C EB58                        jmp .memGetOk
    86                                  
    87                                  ; 0xE801 方法获取物理内存信息
    88                                  .e801MemGetLoop:
    89 0000034E B801E8                      mov ax, 0xe801
    90 00000351 CD15                        int 0x15
    91 00000353 7232                        jc .88MemGetLoop
    92                                  
    93                                      ; 1.算出低15MB的内存
    94                                      ; ax和cx中是KB为单位的内存大小，转换为byte单位
    95 00000355 B90004                      mov cx, 0x400       ; cx和ax值一样，cx作乘数
    96 00000358 F7E1                        mul cx
    97 0000035A 66C1E210                    shl edx, 16
    98 0000035E 6625FFFF0000                and eax, 0x0000ffff
    99 00000364 6609C2                      or edx, eax
   100 00000367 6681C200001000              add edx, 0x100000       ; ax只有15MB，故加1MB
   101 0000036E 6689D6                      mov esi, edx        ; 低15MB的内存容量存入esi备份
   102                                  
   103                                      ; 2.将16MB以上的内存转换为byte单位
   104                                      ; bx和dx中是以64KB为单位的内存大小
   105 00000371 6631C0                      xor eax, eax
   106 00000374 89D8                        mov ax, bx
   107 00000376 66B900000100                mov ecx, 0x10000        ; 64KB
   108 0000037C 66F7E1                      mul ecx
   109                                  
   110 0000037F 6601C6                      add esi, eax
   111 00000382 6689F2                      mov edx, esi
   112 00000385 EB1F                        jmp .memGetOk
   113                                  
   114                                  
   115                                  ; 0x88 方法获取物理内存信息
   116                                  .88MemGetLoop:
   117 00000387 B488                        mov ah, 0x88
   118 00000389 CD15                        int 0x15
   119 0000038B 7220                        jc .errorHlt
   120                                      
   121                                      ; ax单位为KB，将ax的内存大小转换为byte单位
   122 0000038D 6625FFFF0000                and eax, 0x0000ffff
   123 00000393 B90004                      mov cx, 0x400
   124 00000396 F7E1                        mul cx
   125 00000398 66C1E210                    shl edx, 16
   126 0000039C 6609C2                      or edx, eax
   127 0000039F 6681C200001000              add edx, 0x100000       ; 只会返回1MB以上的内存，故实际内存需要加上1MB
   128                                  
   129                                  .memGetOk:
   130 000003A6 668916[0002]                mov [memBytesTotal], edx        ; 保存可用内存总数
   131 000003AB EB03                        jmp readyEntryProtectedMode
   132                                      
   133                                  .errorHlt:
   134 000003AD F4                          hlt
   135 000003AE EBFD                        jmp .errorHlt
   136                                  
   137                                  ; 准备进入保护模式
   138                                  readyEntryProtectedMode:
   139                                      ; 1.打开A20地址线
   140 000003B0 E492                        in al, 0x92
   141 000003B2 0C02                        or al, 0x02
   142 000003B4 E692                        out 0x92, al
   143                                  
   144                                      ; 2.加载GDT
   145 000003B6 0F0116[0402]                lgdt [gdtPtr]
   146                                  
   147                                      ; 3.cr0.PE置1
   148 000003BB 0F20C0                      mov eax, cr0
   149 000003BE 6683C801                    or eax, 0x00000001
   150 000003C2 0F22C0                      mov cr0, eax
   151                                  
   152                                  ; 正式进入保护模式
   153 000003C5 66EA[CD030000]0800          jmp dword SELECTOR_CODE:protectionModeStart     ; 刷新流水线，并加载cs，指令能得以执行是因为实模式和保护模式都会优先使用段缓存寄存器里面的基址，此时cs中的隐藏基址依旧是正确的。
   154                                  
   155                                  [bits 32]
   156                                  protectionModeStart:
   157 000003CD 66B81000                    mov ax, SELECTOR_DATA
   158 000003D1 8ED8                        mov ds, ax
   159 000003D3 8EC0                        mov es, ax
   160 000003D5 8ED0                        mov ss, ax
   161 000003D7 BC00090000                  mov esp, LOADER_STACK_TOP
   162 000003DC 66B81800                    mov ax, SELECTOR_VIDEO
   163 000003E0 8EE8                        mov gs, ax
   164                                      
   165                                  ; 读取kernel.bin
   166 000003E2 B809000000                  mov eax, KERNEL_START_SECTOR
   167 000003E7 BB00000700                  mov ebx, KERNEL_BIN_BASE_ADDR       ; 临时存放内核执行文件，用于拉伸
   168 000003EC B9C8000000                  mov ecx, 200        ; 读取200扇区
   169 000003F1 E8DA000000                  call RdDiskM32
   170                                  
   171                                  
   172                                  
   173                                  
   174                                  ; 准备启用分页模式
   175 000003F6 E82E010000                  call SetupPage
   176                                  
   177 000003FB 0F0105[04020000]            sgdt [gdtPtr]       ; 需要重新加载GDT，先保存
   178                                  
   179 00000402 8B1D[06020000]              mov ebx, [gdtPtr + 2]       ; 获得GDTBase
   180 00000408 814B1C000000C0              or dword [ebx + 0x18 + 4], 0xc0000000       ; GDT[2]是视频段描述符，修改基址
   181 0000040F 8105[06020000]0000-         add dword [gdtPtr + 2], 0xc0000000      ; 启用分页后，访问GDT的地址会变为虚拟地址
   181 00000417 00C0               
   182 00000419 81C4000000C0                add esp, 0xc0000000     ; 栈指针修改为虚拟地址
   183                                  
   184                                      ; cr3是页目录物理地址
   185 0000041F B800001000                  mov eax, PAGE_DIR_TABLE_POS
   186 00000424 0F22D8                      mov cr3, eax
   187                                  
   188                                      ; 开启分页模式
   189 00000427 0F20C0                      mov eax, cr0
   190 0000042A 0D00000080                  or eax, 0x80000000
   191 0000042F 0F22C0                      mov cr0, eax
   192                                  
   193                                      ; cs段描述符缓存的基址都是0，且ip指向的虚拟地址已经提前映射到相同的物理地址上了，所以指令是能够正常继续执行的
   194 00000432 0F0115[04020000]            lgdt [gdtPtr]
   195                                  
   196 00000439 EA[40040000]0800            jmp SELECTOR_CODE:entryKernel       ; 强制刷新流水线，测试没有问题，稳妥起见
   197                                  entryKernel:
   198 00000440 E812000000                  call KernelInit
   199 00000445 83F800                      cmp eax, 0
   200 00000448 740A                        je .error
   201                                  
   202 0000044A BC00F009C0                  mov esp, 0xc009f000
   203 0000044F E9(001500C0)                jmp KERNEL_ENTRY_POINT      ; 控制权交给Kernel
   204                                  
   205                                  .error:
   206 00000454 F4                          hlt
   207 00000455 EBFD                        jmp .error
   208                                  
   209                                  ;----------加载内核----------
   210                                  KernelInit:
   211 00000457 53                          push ebx
   212 00000458 52                          push edx
   213 00000459 57                          push edi
   214                                      
   215                                  
   216 0000045A BB00000700                  mov ebx, KERNEL_BIN_BASE_ADDR
   217                                  
   218 0000045F 66813B4D5A                  cmp word [ebx], 'MZ'
   219 00000464 754E                        jne .error
   220                                  
   221 00000466 BF3C000000                  mov edi, 0x3c
   222                                  
   223 0000046B 031C3B                      add ebx, [ebx+edi]  ; 访问dosHeader.e_lfanew，使ebx指向ntHeader32
   224                                  
   225 0000046E 813B50450000                cmp dword [ebx], 'PE'
   226 00000474 753E                        jne .error
   227                                  
   228 00000476 83C304                      add ebx, 4      ; ebx指向fileHeader
   229                                      
   230 00000479 31C9                        xor ecx, ecx
   231 0000047B 668B4B02                    mov cx, [ebx+0x2]      ; fileHeader.NumberOfSections
   232 0000047F 31C0                        xor eax, eax
   233 00000481 668B4310                    mov ax, [ebx+0x10]      ; fileHeader.SizeOfOptionalHeader
   234                                  
   235                                      
   236 00000485 83C314                      add ebx, 0x14       ; ebx指向optionalHeader32
   237 00000488 8B531C                      mov edx, [ebx+0x1c]     ; optionalHeader32.ImageBase
   238                                  
   239 0000048B 01C3                        add ebx, eax     ; ebx指向sectionsTable
   240                                  
   241                                  
   242                                  ; 遍历节表拷贝节区
   243                                  .copySectionLoop:
   244 0000048D 8B4310                      mov eax, [ebx+0x10]      ; sectionHeader.SizeOfRawData
   245 00000490 50                          push eax        ; size
   246                                  
   247 00000491 8B4314                      mov eax, [ebx+0x14]      ; sectionHeader.PointerToRawData
   248 00000494 0500000700                  add eax, KERNEL_BIN_BASE_ADDR
   249 00000499 50                          push eax        ; src
   250                                  
   251 0000049A 8B430C                      mov eax, [ebx+0xc]      ; sectionHeader.VirtualAddress
   252 0000049D 01D0                        add eax, edx
   253 0000049F 50                          push eax        ; dst
   254                                  
   255 000004A0 E818000000                  call MemCpy
   256 000004A5 83C40C                      add esp, 0xc
   257                                  
   258 000004A8 83C328                      add ebx, 0x28       ; 指向下一个sectionsTable
   259 000004AB E2E0                        loop .copySectionLoop
   260                                  
   261                                  
   262 000004AD B801000000                  mov eax, 1
   263 000004B2 EB05                        jmp .ret
   264                                  .error:
   265 000004B4 B800000000                  mov eax, 0
   266                                  .ret:
   267                                  
   268 000004B9 5F                          pop edi
   269 000004BA 5A                          pop edx
   270 000004BB 5B                          pop ebx
   271 000004BC C3                          ret
   272                                  
   273                                  
   274                                  
   275                                  
   276                                  ;----------内存拷贝----------
   277                                  ; int dst, int src, int size
   278                                  MemCpy:
   279 000004BD FC                          cld
   280 000004BE 55                          push ebp
   281 000004BF 89E5                        mov ebp, esp
   282 000004C1 51                          push ecx        ; rep指令用到了ecx，但ecx对于外层段的循环还有用，故先入栈备份
   283 000004C2 8B7D08                      mov edi, [ebp + 8]      ; dst
   284 000004C5 8B750C                      mov esi, [ebp + 12]     ; src
   285 000004C8 8B4D10                      mov ecx, [ebp + 16]     ; size
   286 000004CB F3A4                        rep movsb       ; 逐字节拷贝
   287                                  
   288                                  
   289 000004CD 59                          pop ecx		
   290 000004CE 5D                          pop ebp
   291 000004CF C3                          ret
   292                                  
   293                                  
   294                                  
   295                                  
   296                                  
   297                                  ;----------读取扇区到内存----------
   298                                  RdDiskM32:
   299 000004D0 89C6                        mov esi, eax
   300 000004D2 6689CF                      mov di, cx
   301                                  
   302                                  ; 1.设置要读取的扇区数
   303 000004D5 66BAF201                    mov dx, 0x1f2
   304 000004D9 88C8                        mov al, cl
   305 000004DB EE                          out dx, al      ; 读取扇区数
   306 000004DC 89F0                        mov eax, esi
   307                                  
   308                                  ; 2.将LBA存入0x1f3 ~ 0x1f6
   309                                      ; bit7 ~ bit0
   310 000004DE 66BAF301                    mov dx, 0x1f3
   311 000004E2 EE                          out dx, al
   312                                  
   313                                      ; bit15 ~ bit8
   314 000004E3 B108                        mov cl, 8
   315 000004E5 D3E8                        shr eax, cl
   316 000004E7 66BAF401                    mov dx, 0x1f4
   317 000004EB EE                          out dx, al
   318                                  
   319                                      ; bit23 ~ bit16
   320 000004EC D3E8                        shr eax, cl
   321 000004EE 66BAF501                    mov dx, 0x1f5
   322 000004F2 EE                          out dx, al
   323                                  
   324                                      ; bit31 ~ bit24
   325 000004F3 D3E8                        shr eax, cl
   326 000004F5 240F                        and al, 0x0f        ; LBA bit27 ~ bit24
   327 000004F7 0CE0                        or al, 0xe0         ; bit31 ~ bit28为1110，表示LBA模式
   328 000004F9 66BAF601                    mov dx, 0x1f6
   329 000004FD EE                          out dx, al
   330                                  
   331                                  ; 3.向0x1f7端口写入读命令，0x20
   332 000004FE 66BAF701                    mov dx, 0x1f7
   333 00000502 B020                        mov al, 0x20
   334 00000504 EE                          out dx, al
   335                                  
   336                                  ; 4.检测硬盘状态
   337                                  .notReady:
   338                                      ; 同一端口，写时表示写入命令字，读时表示读入硬盘状态
   339 00000505 90                          nop
   340 00000506 EC                          in al, dx
   341 00000507 2488                        and al, 0x88        ; bit4为1表示硬盘控制器已准备好数据，bit7为一表示硬盘忙
   342 00000509 3C08                        cmp al, 0x08
   343 0000050B 75F8                        jnz .notReady       ; 未准备好，继续等待
   344                                  
   345                                  ; 5.从0x1f0端口读数据
   346                                      ; di是要读取的扇区数，一个扇区有512字节，每次读入一个字，需要di*512/2次，所以di*256
   347 0000050D 6689F8                      mov ax, di
   348 00000510 66BA0001                    mov dx, 256
   349 00000514 66F7E2                      mul dx
   350 00000517 6689C1                      mov cx, ax
   351                                  
   352 0000051A 66BAF001                    mov dx, 0x1f0
   353                                  .goOnRead:
   354 0000051E 66ED                        in ax, dx
   355 00000520 668903                      mov [ebx], ax
   356 00000523 83C302                      add ebx, 2
   357 00000526 E2F6                        loop .goOnRead
   358 00000528 C3                          ret
   359                                  
   360                                  
   361                                  
   362                                  
   363                                  
   364                                  
   365                                  ; ----------创建页目录及页表----------
   366                                  SetupPage:
   367                                      ; 存放页目录的页面清0
   368 00000529 B900100000                  mov ecx , 0x1000
   369 0000052E BE00000000                  mov esi, 0
   370                                  .clearPageDir:
   371 00000533 C6860000100000              mov byte [PAGE_DIR_TABLE_POS + esi], 0
   372 0000053A 46                          inc esi
   373 0000053B E2F6                        loop .clearPageDir
   374                                  
   375                                      ; 创建页目录项(PDE)
   376                                  .createPDE:
   377 0000053D B800001000                  mov eax, PAGE_DIR_TABLE_POS
   378 00000542 83C807                      or eax, PG_US_U | PG_RW_W | PG_P        ; 加上属性，组成PDE
   379                                  
   380 00000545 A3FC0F1000                  mov [PAGE_DIR_TABLE_POS + 0xffc], eax       ; 写到PDT[0x3ff]中，即页目录自映射
   381                                  
   382                                      ; 创建页表(PTT)
   383 0000054A 0500100000                  add eax, 0x1000     ; 页目录页面之后紧挨着的第一个页面的基址，0x101000，用于PDT[0x300]指向的页表
   384 0000054F A3000C1000                  mov [PAGE_DIR_TABLE_POS + 0xc00], eax       ; 写到PDT[0x300]中
   385 00000554 A300001000                  mov [PAGE_DIR_TABLE_POS + 0x0], eax       ; 写到PDT[0x0]中
   386                                  
   387                                  
   388                                      ; 创建页表项(PTE)，将物理地址 0x00000 ~ 0xfffff 映射到虚拟地址 0x00000000 ~ 0x000fffff 和 0xc0000000 ~ 0xc00fffff
   389 00000559 BB00001000                  mov ebx, PAGE_DIR_TABLE_POS
   390 0000055E 81C300100000                add ebx, 0x1000     ; PDT[0x300]指向的页表
   391 00000564 B900010000                  mov ecx, 256        ; 256项
   392 00000569 BE00000000                  mov esi, 0
   393 0000056E BA07000000                  mov edx, PG_US_U | PG_RW_W | PG_P       ; base为0
   394                                  .createPTE:
   395 00000573 8914B3                      mov [ebx+esi*4], edx        ; PDT[0x300]指向的页表
   396 00000576 81C200100000                add edx, 0x1000     ; base += 0x1000
   397 0000057C 46                          inc esi
   398 0000057D E2F4                        loop .createPTE
   399                                  
   400                                      ; 为内核剩余页目录项分配页表
   401 0000057F B800001000                  mov eax, PAGE_DIR_TABLE_POS
   402 00000584 0500200000                  add eax, 0x2000     ; 页目录页面之后紧挨着的第二个页面的基址，0x102000，用于PDT[0x301]指向的页表
   403 00000589 83C807                      or eax, PG_US_U | PG_RW_W | PG_P
   404 0000058C BB00001000                  mov ebx, PAGE_DIR_TABLE_POS
   405 00000591 B9FE000000                  mov ecx, 254
   406 00000596 BE01030000                  mov esi, 0x301      ; 范围为 0x301 ~ 0x3fe 的所有PDE
   407                                  .createKernelPDE:
   408 0000059B 8904B3                      mov [ebx+esi*4], eax
   409 0000059E 46                          inc esi
   410 0000059F 0500100000                  add eax, 0x1000     ; 继续使用下一个物理页面当作PTT
   411 000005A4 E2F5                        loop .createKernelPDE
   412 000005A6 C3                          ret
